<# 
  Genesys Cloud (AU) – Presence analytics with pagination + 429 retry
  Detects ON_QUEUE → AVAILABLE → ON_QUEUE patterns.
  Adds presence + routing status summary columns to the triplet CSV.
  PowerShell 5.1 compatible. No external modules required.
#>

param(
  [string]$Region        = "mypurecloud.com.au",
  [string]$ClientId      = "b5cfd3ca-e1e0-4af2-86ba-a815f618e62a",
  [string]$ClientSecret  = "hPp4KSICLFJV1hoMsoxTXuXKY594TkKmsKcA2IjsrnE",
  [string]$Interval      = "2025-10-15T13:00:00.000Z/2025-10-17T13:00:00.000Z",
  [int]   $PageSize      = 100,
  [bool]  $ResolveNames  = $true,
  [int]   $StartPage     = 1,
  [int]   $ThrottleMs    = 250
)

# ---------- Helpers ----------
function Get-AccessToken {
  param([string]$Region, [string]$ClientId, [string]$ClientSecret)
  $tokenUrl = "https://login.$Region/oauth/token"
  $pair     = "{0}:{1}" -f $ClientId, $ClientSecret
  $b64      = [Convert]::ToBase64String([Text.Encoding]::UTF8.GetBytes($pair))
  $headers  = @{ Authorization = "Basic $b64"; "Content-Type" = "application/x-www-form-urlencoded" }
  $body     = "grant_type=client_credentials"
  try {
    $resp = Invoke-RestMethod -Method Post -Uri $tokenUrl -Headers $headers -Body $body
    if (-not $resp.access_token) { throw "No access_token in response." }
    return $resp.access_token
  } catch {
    throw "Failed to obtain access token: $($_.Exception.Message)"
  }
}

function Invoke-GenesysApi {
  param(
    [ValidateSet('GET','POST','PUT','DELETE','PATCH')]
    [string]$Method,
    [string]$Path,
    [hashtable]$Headers,
    [object]$Body = $null,
    [int]$MaxRetries = 8
  )
  $base = "https://api.$Region"
  $uri  = if ($Path -like "http*") { $Path } else { "$base$Path" }

  $attempt = 0
  while ($true) {
    try {
      if ($Body -ne $null -and $Method -in @('POST','PUT','PATCH')) {
        $json = $Body | ConvertTo-Json -Depth 20
        return Invoke-RestMethod -Method $Method -Uri $uri -Headers $Headers -Body $json -ContentType "application/json"
      } else {
        return Invoke-RestMethod -Method $Method -Uri $uri -Headers $Headers
      }
    }
    catch {
      $attempt++
      $statusCode = try { [int]$_.Exception.Response.StatusCode } catch { 0 }
      if ($statusCode -ne 429 -or $attempt -gt $MaxRetries) { throw }

      $retryAfter = 0
      try {
        $resp = $_.Exception.Response
        if ($resp -and $resp.Headers['Retry-After']) {
          $retryAfter = [int]$resp.Headers['Retry-After']
        } else {
          $sr = New-Object IO.StreamReader($resp.GetResponseStream())
          $text = $sr.ReadToEnd()
          if ($text -match 'Retry the request in \[(\d+)\] seconds') { $retryAfter = [int]$matches[1] }
        }
      } catch {}

      if ($retryAfter -lt 1) { $retryAfter = [math]::Min(60, [int]([math]::Pow(2, $attempt) + (Get-Random -Minimum 0 -Maximum 2))) }
      Write-Warning ("429 received. Waiting {0}s then retrying (attempt {1}/{2})..." -f $retryAfter, $attempt, $MaxRetries)
      Start-Sleep -Seconds $retryAfter
    }
  }
}

function Get-UserName {
  param([string]$UserId, [hashtable]$Headers)
  if (-not $script:UserNameCache) { $script:UserNameCache = @{} }
  if ($script:UserNameCache.ContainsKey($UserId)) { return $script:UserNameCache[$UserId] }
  try {
    $u = Invoke-GenesysApi -Method GET -Path "/api/v2/users/$UserId" -Headers $Headers
    $name = if ($u.name) { $u.name } else { $u.id }
    $script:UserNameCache[$UserId] = $name
    return $name
  } catch {
    $script:UserNameCache[$UserId] = $UserId
    return $UserId
  }
}

function To-Date {
  param([string]$s)
  if ([string]::IsNullOrWhiteSpace($s)) { return $null }
  try { return [datetime]::Parse($s, $null, [System.Globalization.DateTimeStyles]::AssumeUniversal) } catch { return $null }
}

# Summarize routingStatus over a window [winStart, winEnd): returns "STATUS1=secs; STATUS2=secs"
function Summarize-RoutingStatus {
  param(
    [object[]]$RoutingStatuses,   # ud.routingStatus array
    [datetime]$WinStart,
    [datetime]$WinEnd
  )
  if (-not $RoutingStatuses -or -not $WinStart) { return $null }
  if (-not $WinEnd) { $WinEnd = [DateTime]::UtcNow }

  $totals = @{}
  foreach ($rs in $RoutingStatuses) {
    $rsStart = To-Date $rs.startTime
    if (-not $rsStart) { continue }
    $rsEnd   = To-Date $rs.endTime
    if (-not $rsEnd) { $rsEnd = [DateTime]::UtcNow }

    # Overlap calculation
    $ovStart = if ($rsStart -gt $WinStart) { $rsStart } else { $WinStart }
    $ovEnd   = if ($rsEnd   -lt $WinEnd)   { $rsEnd }   else { $WinEnd }
    if ($ovEnd -le $ovStart) { continue }

    $secs = [int][math]::Round(($ovEnd - $ovStart).TotalSeconds)
    $key  = if ($rs.routingStatus) { [string]$rs.routingStatus } else { 'UNKNOWN' }
    if ($totals.ContainsKey($key)) { $totals[$key] += $secs } else { $totals[$key] = $secs }
  }

  if ($totals.Count -eq 0) { return $null }
  ($totals.GetEnumerator() | Sort-Object Value -Descending | ForEach-Object { "{0}={1}" -f $_.Key, $_.Value }) -join "; "
}

# ---------- Main ----------
try { [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12 } catch {}

$token       = Get-AccessToken -Region $Region -ClientId $ClientId -ClientSecret $ClientSecret
$authHeaders = @{ Authorization = "Bearer $token" }

$pageNumber   = [Math]::Max(1, $StartPage)
$totalHits    = $null

$allPresenceRows = New-Object System.Collections.Generic.List[object]
$onQueueToAvail  = New-Object System.Collections.Generic.List[object]
$oqAvailOqList   = New-Object System.Collections.Generic.List[object]

Write-Host "Querying /api/v2/analytics/users/details/query for interval $Interval ..." -ForegroundColor Cyan

do {
  $body = @{
    interval = $Interval
    order    = "asc"
    paging   = @{
      pageSize   = "$PageSize"
      pageNumber = $pageNumber
    }
  }

  $resp = Invoke-GenesysApi -Method POST -Path "/api/v2/analytics/users/details/query" -Headers $authHeaders -Body $body

  if ($null -eq $resp -or -not $resp.userDetails) {
    Write-Warning "No userDetails on page $pageNumber."
    break
  }

  if ($null -eq $totalHits -and $resp.totalHits) { $totalHits = [int]$resp.totalHits }

  foreach ($ud in $resp.userDetails) {
    $userId   = $ud.userId
    $userName = if ($ResolveNames) { Get-UserName -UserId $userId -Headers $authHeaders } else { $userId }

    # Collect presence blocks + export all blocks with seconds
    $blocks = @()
    foreach ($p in ($ud.primaryPresence | ForEach-Object { $_ })) {
      $pStart = To-Date $p.startTime
      $pEnd   = To-Date $p.endTime
      if ($null -eq $pStart) { continue }
      $effectiveEnd = if ($pEnd) { $pEnd } else { [DateTime]::UtcNow }
      $seconds      = [int][math]::Round(($effectiveEnd - $pStart).TotalSeconds)

      $allPresenceRows.Add([pscustomobject]@{
        UserId        = $userId
        UserName      = $userName
        Presence      = $p.systemPresence
        OrgPresenceId = $p.organizationPresenceId
        StartTimeUtc  = $pStart.ToString("o")
        EndTimeUtc    = if ($pEnd) { $pEnd.ToString("o") } else { $null }
        Seconds       = $seconds
      })

      $blocks += [pscustomobject]@{
        Start = $pStart
        End   = $pEnd
        Pres  = $p.systemPresence
        Sec   = $seconds
      }
    }

    # Ensure chronological
    $blocks = $blocks | Sort-Object Start

    # Adjacent ON_QUEUE -> AVAILABLE pairs
    for ($i = 1; $i -lt $blocks.Count; $i++) {
      $prev = $blocks[$i-1]
      $curr = $blocks[$i]
      if ($prev.Pres -eq 'ON_QUEUE' -and $curr.Pres -eq 'AVAILABLE') {
        $prevEnd  = if ($prev.End) { $prev.End } else { [DateTime]::UtcNow }
        $gapSecs  = [int][math]::Round(($curr.Start - $prevEnd).TotalSeconds)

        $onQueueToAvail.Add([pscustomobject]@{
          UserId           = $userId
          UserName         = $userName
          PrevPresence     = $prev.Pres
          PrevStartTimeUtc = $prev.Start.ToString("o")
          PrevEndTimeUtc   = if ($prev.End) { $prev.End.ToString("o") } else { $null }
          PrevSeconds      = $prev.Sec
          CurrPresence     = $curr.Pres
          CurrStartTimeUtc = $curr.Start.ToString("o")
          CurrEndTimeUtc   = if ($curr.End) { $curr.End.ToString("o") } else { $null }
          CurrSeconds      = $curr.Sec
          GapSeconds       = $gapSecs
        })
      }
    }

    # Triplets: ON_QUEUE -> AVAILABLE -> ON_QUEUE
    for ($i = 2; $i -lt $blocks.Count; $i++) {
      $one   = $blocks[$i-2]
      $two   = $blocks[$i-1]
      $three = $blocks[$i]

      if ($one.Pres -eq 'ON_QUEUE' -and $two.Pres -eq 'AVAILABLE' -and $three.Pres -eq 'ON_QUEUE') {
        $oneEnd   = if ($one.End)   { $one.End }   else { [DateTime]::UtcNow }
        $twoEnd   = if ($two.End)   { $two.End }   else { [DateTime]::UtcNow }
        $threeEnd = if ($three.End) { $three.End } else { [DateTime]::UtcNow }   # <-- fix: no ternary

        # RoutingStatus summaries for each segment window
        $rs1 = Summarize-RoutingStatus -RoutingStatuses $ud.routingStatus -WinStart $one.Start   -WinEnd $oneEnd
        $rs2 = Summarize-RoutingStatus -RoutingStatuses $ud.routingStatus -WinStart $two.Start   -WinEnd $twoEnd
        $rs3 = Summarize-RoutingStatus -RoutingStatuses $ud.routingStatus -WinStart $three.Start -WinEnd $threeEnd

        $oqAvailOqList.Add([pscustomobject]@{
          UserId                = $userId
          UserName              = $userName

          # First ON_QUEUE block
          FirstOnQueue_Presence = 'ON_QUEUE'
          FirstOnQueue_StartUtc = $one.Start.ToString("o")
          FirstOnQueue_EndUtc   = if ($one.End)   { $one.End.ToString("o") }   else { $null }
          FirstOnQueue_Seconds  = $one.Sec
          FirstOnQueue_RoutingStatus = $rs1

          # AVAILABLE block
          Available_Presence    = 'AVAILABLE'
          Available_StartUtc    = $two.Start.ToString("o")
          Available_EndUtc      = if ($two.End)   { $two.End.ToString("o") }   else { $null }
          Available_Seconds     = $two.Sec
          Available_RoutingStatus = $rs2

          # Next ON_QUEUE block
          NextOnQueue_Presence  = 'ON_QUEUE'
          NextOnQueue_StartUtc  = $three.Start.ToString("o")
          NextOnQueue_EndUtc    = if ($three.End) { $three.End.ToString("o") } else { $null }
          NextOnQueue_Seconds   = $three.Sec
          NextOnQueue_RoutingStatus = $rs3
        })
      }
    }
  }

  $processed = $pageNumber * $PageSize
  $totalHitsText = if ($null -ne $totalHits) { $totalHits } else { 'unknown' }
  Write-Host ("Processed page {0}. presenceRows={1}. totalHits={2}" -f $pageNumber, $allPresenceRows.Count, $totalHitsText)

  if ($ThrottleMs -gt 0) { Start-Sleep -Milliseconds $ThrottleMs }
  $pageNumber++

  $moreLikely = $false
  if ($resp.userDetails.Count -eq $PageSize) { $moreLikely = $true }
  if ($null -ne $totalHits) { $moreLikely = ($processed -lt $totalHits) }
} while ($moreLikely)

# ---------- Export ----------
$stamp   = (Get-Date).ToUniversalTime().ToString("yyyyMMdd_HHmmss")
$allCsv  = "Presence_AllBlocks_$stamp.csv"
$tranCsv = "Presence_OnQueueToAvailable_$stamp.csv"
$tripCsv = "Presence_OQ_Available_OQ_$stamp.csv"

$allPresenceRows | Export-Csv -NoTypeInformation -Encoding UTF8 -Path $allCsv
$onQueueToAvail  | Export-Csv -NoTypeInformation -Encoding UTF8 -Path $tranCsv
$oqAvailOqList   | Export-Csv -NoTypeInformation -Encoding UTF8 -Path $tripCsv

Write-Host ""
Write-Host "✅ Done."
Write-Host "• All blocks:                   $allCsv"  -ForegroundColor Green
Write-Host "• ON_QUEUE → AVAILABLE pairs:   $tranCsv" -ForegroundColor Green
Write-Host "• OQ → AVAILABLE → OQ triplets: $tripCsv" -ForegroundColor Green
Write-Host ""

# Console summary (triplets)
if ($oqAvailOqList.Count -gt 0) {
  Write-Host "Top users by OQ→Available→OQ triplets:" -ForegroundColor Yellow
  $oqAvailOqList | Group-Object UserName | Sort-Object Count -Descending |
    Select-Object @{n='User';e={$_.Name}}, @{n='Triplets';e={$_.Count}} | Format-Table -AutoSize
} else {
  Write-Host "No OQ→Available→OQ triplets found in the interval." -ForegroundColor Yellow
}
