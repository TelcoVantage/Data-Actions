<# 
    Genesys Cloud â€“ Pull audits for a single user (last 12 days) 111111111111111111
    - Queries both:
        A) events performed by the user (actor)
        B) events targeting that user as the entity
    - Asynchronous Audits API flow:
        POST  /api/v2/audits/query     -> 202 + transactionId
        GET   /api/v2/audits/query/{transactionId}
        GET   /api/v2/audits/query/{transactionId}/results (with nextUri paging)
    - Outputs: audits_{USERID}_YYYYMMDD_HHmm.csv and .json
#>

# ------------------- CONFIG: FILL THESE -------------------
$CLIENT_ID     = "<PUT_YOUR_CLIENT_ID_HERE>"
$CLIENT_SECRET = "<PUT_YOUR_CLIENT_SECRET_HERE>"
$ORG_REGION    = "mypurecloud.com.au"   # e.g., mypurecloud.com, mypurecloud.ie, etc.
$TARGET_USER_ID = "<PUT_TARGET_USER_GUID_HERE>"
$DAYS_BACK = 12
# ------------------- END CONFIG ---------------------------

# ---------- Time interval (UTC) ----------
$nowUtc   = (Get-Date).ToUniversalTime()
$startUtc = $nowUtc.AddDays(-$DAYS_BACK)
$interval = "{0}/{1}" -f ($startUtc.ToString("yyyy-MM-ddTHH:mm:ssZ")), ($nowUtc.ToString("yyyy-MM-ddTHH:mm:ssZ"))

# ---------- OAuth: Client Credentials ----------
$tokenUrl = "https://login.$ORG_REGION/oauth/token"
$pair     = "{0}:{1}" -f $CLIENT_ID, $CLIENT_SECRET
$basic    = [Convert]::ToBase64String([Text.Encoding]::ASCII.GetBytes($pair))
$headers  = @{ "Authorization" = "Basic $basic" }

try {
    $tokenResp = Invoke-RestMethod -Method Post -Uri $tokenUrl -Headers $headers `
        -ContentType "application/x-www-form-urlencoded" -Body "grant_type=client_credentials"
} catch {
    Write-Error "Failed to obtain token. Check client ID/secret/region and client roles. $($_.Exception.Message)"
    exit 1
}

$accessToken = $tokenResp.access_token
if (-not $accessToken) { Write-Error "No access_token in token response."; exit 1 }

# ---------- Common API setup ----------
$apiBase = "https://api.$ORG_REGION"
$authz   = @{ "Authorization" = "Bearer $accessToken"; "Content-Type" = "application/json" }

function Start-AuditQuery {
    param([Parameter(Mandatory)] [hashtable] $Body)
    $url = "$apiBase/api/v2/audits/query"
    $json = ($Body | ConvertTo-Json -Depth 10)
    try {
        $resp = Invoke-WebRequest -Method Post -Uri $url -Headers $authz -Body $json
        if ($resp.StatusCode -ne 202) { throw "Unexpected status code: $($resp.StatusCode) body: $($resp.Content)" }
        ($resp.Content | ConvertFrom-Json).id
    } catch { throw "Audit query create failed: $($_.Exception.Message)" }
}

function Wait-AuditQueryReady {
    param(
        [Parameter(Mandatory)] [string] $TransactionId,
        [int] $TimeoutSec = 120,
        [int] $PollMs = 1200
    )
    $statusUrl = "$apiBase/api/v2/audits/query/$TransactionId"
    $sw = [Diagnostics.Stopwatch]::StartNew()
    while ($sw.Elapsed.TotalSeconds -lt $TimeoutSec) {
        try {
            $s = Invoke-RestMethod -Method Get -Uri $statusUrl -Headers $authz
            if ($s.state -in @("Complete","Succeeded")) { return $true }
            if ($s.state -in @("Failed","Cancelled","TimedOut")) { throw "Query state: $($s.state). Message: $($s.errorMessage)" }
        } catch { throw "Status check failed: $($_.Exception.Message)" }
        Start-Sleep -Milliseconds $PollMs
    }
    throw "Timed out waiting for audit query to complete."
}

function Get-AuditResultsAllPages {
    param([Parameter(Mandatory)] [string] $TransactionId)
    $results = @()
    $url = "$apiBase/api/v2/audits/query/$TransactionId/results"
    while ($true) {
        $resp = Invoke-RestMethod -Method Get -Uri $url -Headers $authz
        if ($resp.entities) { $results += $resp.entities }
        if ($resp.nextUri) { $url = "$apiBase$($resp.nextUri)" } else { break }
    }
    $results
}

# ---------- Build two queries ----------
# Actor = events performed BY the user
$bodyActor = @{
    interval = $interval
    userIds  = @($TARGET_USER_ID)   # actor filter
    pageSize = 100
}

# Entity = events targeting that user (their record changed)
$bodyEntity = @{
    interval = $interval
    filters  = @(
        @{ property = "EntityType"; values = @("User") },
        @{ property = "EntityId";   values = @($TARGET_USER_ID) }
    )
    pageSize = 100
}

Write-Host "Submitting audit queries for interval $interval ..."

try {
    $txActor  = Start-AuditQuery -Body $bodyActor
    $txEntity = Start-AuditQuery -Body $bodyEntity

    Write-Host "Actor transactionId : $txActor"
    Write-Host "Entity transactionId: $txEntity"

    [void](Wait-AuditQueryReady -TransactionId $txActor)
    [void](Wait-AuditQueryReady -TransactionId $txEntity)

    $actorEvents  = Get-AuditResultsAllPages -TransactionId $txActor
    $entityEvents = Get-AuditResultsAllPages -TransactionId $txEntity
} catch { Write-Error $_; exit 1 }

# ---------- Merge, de-dup (by id), sort ----------
$all = @($actorEvents + $entityEvents) | Group-Object id | ForEach-Object { $_.Group[0] } |
       Sort-Object -Property timestamp -Descending

if (-not $all -or $all.Count -eq 0) {
    Write-Host "No audit events found for user $TARGET_USER_ID in the last $DAYS_BACK days."
    return
}

# ---------- Outputs ----------
$stamp   = (Get-Date).ToString("yyyyMMdd_HHmm")
$baseOut = "audits_$($TARGET_USER_ID)_$stamp"

$all | ConvertTo-Json -Depth 20 | Out-File -Encoding UTF8 -FilePath "$baseOut.json"

$flat = $all | ForEach-Object {
    $pc = $_.propertyChanges
    $changes = $null
    if ($pc) {
        $changes = ($pc | ForEach-Object {
            $n = $_.property
            $o = if ($_.oldValues) { ($_.oldValues -join "|") } else { "" }
            $v = if ($_.newValues) { ($_.newValues -join "|") } else { "" }
            "$n: $o -> $v"
        }) -join "; "
    }
    [pscustomobject]@{
        Timestamp     = $_.timestamp
        ServiceName   = $_.serviceName
        Action        = $_.action
        EntityType    = $_.entityType
        EntityId      = $_.entityId
        EntityName    = $_.entityName
        UserId        = $_.userId
        UserName      = $_.userName
        CorrelationId = $_.correlationId
        IPAddress     = $_.ipAddress
        Application   = $_.application
        Changes       = $changes
    }
}

$flat | Export-Csv -NoTypeInformation -Encoding UTF8 -Path "$baseOut.csv"

Write-Host "`nDone."
Write-Host "JSON: $baseOut.json"
Write-Host "CSV : $baseOut.csv"
