# Export-Workflow-ExecutionFrames.ps1
# Built-in PowerShell/.NET only (no external modules).
# Output: CSV with one row per execution frame (including path taken + metadata).

# =========================
# CONFIG (edit these 5 lines)
# =========================
$ClientId     = 'PUT_YOUR_CLIENT_ID_HERE'
$ClientSecret = 'PUT_YOUR_CLIENT_SECRET_HERE'
$Environment  = 'mypurecloud.com.au'   # e.g. mypurecloud.com, mypurecloud.ie, usw2.pure.cloud
$WorkflowName = ''                     # Optional filter (exact/partial name). Leave blank for ALL workflows.
# Date window (local time): set either DaysBack or explicit Start/End
$DaysBack     = 0                      # 0=today, 1=yesterday, etc. Ignored if you set $StartLocal/$EndLocal below.

# OPTIONAL: set explicit local dates (uncomment to use a custom window instead of $DaysBack)
# $StartLocal = [datetime]'2025-08-01 00:00:00'
# $EndLocal   = [datetime]'2025-08-01 23:59:59'

# =========================
# ADVANCED (leave as-is)
# =========================
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
$BaseApi = "https://api.$Environment"
$Login   = "https://login.$Environment"
$Now     = Get-Date
$OutCsv  = Join-Path (Get-Location) ("WorkflowExecutionFrames_{0:yyyyMMdd_HHmmss}.csv" -f $Now)

# Compute interval (UTC ISO 8601)
if (-not $StartLocal -or -not $EndLocal) {
    $StartLocal = (Get-Date).Date.AddDays(-1 * [int]$DaysBack)
    $EndLocal   = $StartLocal.AddDays(1).AddSeconds(-1)
}
$StartUtc = $StartLocal.ToUniversalTime()
$EndUtc   = $EndLocal.ToUniversalTime()
$Interval = "{0:o}/{1:o}" -f $StartUtc, $EndUtc

# ----------------- Helpers -----------------
function Get-AccessToken {
    param([string]$ClientId, [string]$ClientSecret, [string]$Login)
    $pair    = '{0}:{1}' -f $ClientId, $ClientSecret
    $b64     = [Convert]::ToBase64String([Text.Encoding]::ASCII.GetBytes($pair))
    $headers = @{ Authorization = "Basic $b64" }
    $body    = "grant_type=client_credentials"
    try {
        $resp = Invoke-RestMethod -Method POST -Uri "$Login/oauth/token" `
            -Headers $headers -ContentType "application/x-www-form-urlencoded" -Body $body
        return $resp.access_token
    } catch {
        throw "Auth failed: $($_.Exception.Message)"
    }
}

function Invoke-GC {
    param(
        [Parameter(Mandatory)] [string]$Method,
        [Parameter(Mandatory)] [string]$Path,
        [string]$Token,
        [object]$Body = $null,
        [hashtable]$ExtraHeaders = $null
    )
    $headers = @{ Authorization = "Bearer $Token" }
    if ($ExtraHeaders) { $ExtraHeaders.GetEnumerator() | ForEach-Object { $headers[$_.Key] = $_.Value } }
    $uri = if ($Path -like 'http*') { $Path } else { "$BaseApi$Path" }
    if ($Body -ne $null -and -not ($Body -is [string])) { $Body = ($Body | ConvertTo-Json -Depth 12) }
    return Invoke-RestMethod -Method $Method -Uri $uri -Headers $headers -ContentType "application/json" -Body $Body
}

function Get-AllWorkflows {
    param([string]$Token)
    $all = @()
    $page = 1
    do {
        $resp = Invoke-GC -Method GET -Path "/api/v2/flows?pageSize=200&pageNumber=$page" -Token $Token
        $entities = @()
        if ($resp.entities) { $entities = $resp.entities }
        elseif ($resp.items) { $entities = $resp.items }
        $workflows = $entities | Where-Object { $_.type -eq 'WORKFLOW' }
        $all += $workflows
        $page += 1
        $more = ($entities.Count -gt 0 -and ($resp.nextUri -or ($resp.pageCount -as [int]) -ge ($page)))
    } while ($more)
    return $all
}

function Find-WorkflowIds {
    param([string]$Token, [string]$Name)
    $flows = Get-AllWorkflows -Token $Token
    if ([string]::IsNullOrWhiteSpace($Name)) { return $flows.id }
    $matched = $flows | Where-Object { $_.name -like "*$Name*" }
    if (-not $matched) { throw "No workflows matched name '$Name'." }
    return $matched.id
}

function Query-FlowInstances {
    param([string]$Token, [string[]]$FlowIds, [string]$Interval)

    # Base filter: only workflows
    $preds = @(@{ type='dimension'; dimension='flowType'; value='workflow' })

    $filter = if ($FlowIds -and $FlowIds.Count -gt 0) {
        @{
            type='and'
            predicates = $preds
            clauses    = @(@{
                type='or'
                predicates = ($FlowIds | ForEach-Object { @{ type='dimension'; dimension='flowId'; value=$_ } })
            })
        }
    } else {
        @{ type='and'; predicates = $preds }
    }

    $pageNumber = 1
    $pageSize   = 100
    $allIds     = New-Object System.Collections.Generic.List[string]

    while ($true) {
        $body = @{
            interval = $Interval
            filter   = $filter
            groupBy  = @('flowInstanceId','flowId','flowName','flowVersion')
            metrics  = @()
            paging   = @{ pageNumber = $pageNumber; pageSize = $pageSize }
        }
        $resp = Invoke-GC -Method POST -Path "/api/v2/analytics/flows/aggregates/query" -Token $Token -Body $body
        if (-not $resp.results -or $resp.results.Count -eq 0) { break }

        foreach ($r in $resp.results) {
            if ($r.group.flowInstanceId) { $allIds.Add([string]$r.group.flowInstanceId) }
        }

        # stop when fewer than pageSize returned
        if ($resp.results.Count -lt $pageSize) { break }
        $pageNumber++
    }

    ($allIds.ToArray() | Select-Object -Unique)
}

function Start-ExecutionExportJob {
    param(
        [string]$Token,
        [string]$Interval,
        [string[]]$FlowInstanceIds = $null,
        [string[]]$FlowIds = $null
    )
    $predBase = @(@{ type='dimension'; dimension='flowType'; value='workflow' })
    $clauses = @()

    if ($FlowInstanceIds -and $FlowInstanceIds.Count -gt 0) {
        $clauses += @{
            type='or'
            predicates= ($FlowInstanceIds | ForEach-Object { @{ type='dimension'; dimension='flowInstanceId'; value=$_ } })
        }
    } elseif ($FlowIds -and $FlowIds.Count -gt 0) {
        $clauses += @{
            type='or'
            predicates= ($FlowIds | ForEach-Object { @{ type='dimension'; dimension='flowId'; value=$_ } })
        }
    }

    $jobBody = @{
        interval = $Interval
        filter   = @{
            type      = 'and'
            predicates= $predBase
            clauses   = $clauses
        }
    }
    $job = Invoke-GC -Method POST -Path "/api/v2/analytics/flows/executions/jobs" -Token $Token -Body $jobBody
    $job.id
}

function Wait-Job {
    param([string]$Token, [string]$JobId, [int]$TimeoutSec = 300)
    $expiry = (Get-Date).AddSeconds($TimeoutSec)
    do {
        $s = Invoke-GC -Method GET -Path "/api/v2/analytics/flows/executions/jobs/$JobId" -Token $Token
        if ($s.state -eq 'FULFILLED') { return $s.resultsUrl }
        if ($s.state -eq 'FAILED')   { throw "Export job failed: $($s | ConvertTo-Json -Depth 12)" }
        Start-Sleep -Seconds 3
    } while ((Get-Date) -lt $expiry)
    throw "Export job timed out after $TimeoutSec seconds."
}

function Get-JsonFromGzipUrl {
    param([string]$Url)
    $tmpGz = [System.IO.Path]::GetTempFileName()
    try {
        Invoke-WebRequest -Uri $Url -OutFile $tmpGz | Out-Null
        $fs = [System.IO.File]::OpenRead($tmpGz)
        $gs = New-Object System.IO.Compression.GzipStream($fs, [System.IO.Compression.CompressionMode]::Decompress)
        $sr = New-Object System.IO.StreamReader($gs, [Text.Encoding]::UTF8)
        $json = $sr.ReadToEnd()
        $sr.Close(); $gs.Close(); $fs.Close()
        $json
    } finally {
        if (Test-Path $tmpGz) { Remove-Item $tmpGz -Force -ErrorAction SilentlyContinue }
    }
}

function Coalesce {
    param([Parameter(ValueFromRemainingArguments=$true)] $values)
    foreach ($v in $values) {
        if ($null -ne $v -and -not ([string]::IsNullOrWhiteSpace([string]$v))) { return $v }
    }
    $null
}

# ----------------- MAIN -----------------
Write-Host "Authenticating to Genesys Cloud ($Environment)..." -ForegroundColor Cyan
$Token = Get-AccessToken -ClientId $ClientId -ClientSecret $ClientSecret -Login $Login
Write-Host ("OK. Interval (UTC): {0}" -f $Interval) -ForegroundColor Green

# Optional workflow name filter
$FlowIds = @()
if (-not [string]::IsNullOrWhiteSpace($WorkflowName)) {
    Write-Host "Finding workflow(s) matching: $WorkflowName" -ForegroundColor Cyan
    $FlowIds = Find-WorkflowIds -Token $Token -Name $WorkflowName
    Write-Host ("Matched {0} workflow id(s)." -f $FlowIds.Count) -ForegroundColor Green
}

# Get all flow instances in window
Write-Host "Querying workflow flowInstanceIds for interval..." -ForegroundColor Cyan
$InstanceIds = Query-FlowInstances -Token $Token -FlowIds $FlowIds -Interval $Interval
if (-not $InstanceIds -or $InstanceIds.Count -eq 0) {
    Write-Host "No workflow executions found in the selected interval." -ForegroundColor Yellow
    return
}
Write-Host ("Found {0} instance(s)." -f $InstanceIds.Count) -ForegroundColor Green

# Export events; chunk instanceIds to keep requests reasonable
$AllEvents = New-Object System.Collections.Generic.List[object]
$chunkSize = 200
for ($i = 0; $i -lt $InstanceIds.Count; $i += $chunkSize) {
    $slice = $InstanceIds[$i..([Math]::Min($i+$chunkSize-1,$InstanceIds.Count-1))]
    Write-Host ("Starting export job for {0} instanceIds ({1}-{2})..." -f $slice.Count, $i+1, $i+$slice.Count) -ForegroundColor Cyan

    $jobId = Start-ExecutionExportJob -Token $Token -Interval $Interval -FlowInstanceIds $slice
    $url   = Wait-Job -Token $Token -JobId $jobId -TimeoutSec 420
    $json  = Get-JsonFromGzipUrl -Url $url

    $payload = $json | ConvertFrom-Json
    $events = if ($payload.flowExecutionEvents) { $payload.flowExecutionEvents } else { $payload }

    foreach ($e in $events) { [void]$AllEvents.Add($e) }
}

if ($AllEvents.Count -eq 0) {
    Write-Host "Export completed, but no events returned (check execution data settings / permissions)." -ForegroundColor Yellow
    return
}

Write-Host ("Flattening {0} execution event(s)..." -f $AllEvents.Count) -ForegroundColor Cyan

$rows = foreach ($e in $AllEvents) {
    $flowId         = Coalesce $e.flowId $e.flow?.id
    $flowName       = Coalesce $e.flowName $e.flow?.name
    $flowVersion    = Coalesce $e.flowVersion $e.flow?.version
    $flowInstanceId = Coalesce $e.flowInstanceId $e.flow?.flowInstanceId $e.instanceId
    $executionId    = Coalesce $e.executionId $e.execution?.id
    $timestampUtc   = Coalesce $e.eventDateTime $e.timestamp
    $objectType     = Coalesce $e.objectType $e.actionType
    $objectName     = Coalesce $e.objectName $e.actionName
    $eventName      = Coalesce $e.eventName $e.event

    # Attempt to infer branch/path taken across common block types
    $pathHint = Coalesce `
        $e.outputData?.path `
        $e.outputData?.caseLabel `
        $e.outputData?.choice `
        $e.outputData?.selectedMenuChoice `
        $e.outputData?.selectedValue `
        $e.inputData?.path `
        $e.inputData?.choice `
        $e.framePath `
        $e.branch

    $err = $null
    if ($e.errorInfo) { $err = ($e.errorInfo | ConvertTo-Json -Compress -Depth 8) }

    [PSCustomObject]@{
        FlowName        = $flowName
        FlowId          = $flowId
        FlowVersion     = $flowVersion
        FlowInstanceId  = $flowInstanceId
        ExecutionId     = $executionId
        EventTimeUtc    = $timestampUtc
        ObjectType      = $objectType
        ObjectName      = $objectName
        EventName       = $eventName
        PathTaken       = $pathHint
        InputJson       = if ($e.inputData)  { $e.inputData  | ConvertTo-Json -Compress -Depth 8 } else { $null }
        OutputJson      = if ($e.outputData) { $e.outputData | ConvertTo-Json -Compress -Depth 8 } else { $null }
        ErrorJson       = $err
    }
}

$rows | Export-Csv -NoTypeInformation -Encoding UTF8 -Path $OutCsv
Write-Host "`nDONE. CSV saved to:`n$OutCsv" -ForegroundColor Green
