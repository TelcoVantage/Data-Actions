# Export-Workflow-ExecutionFrames.ps1
# Requires: nothing extra (built-in PowerShell + .NET only)
# Output: CSV in current folder with all Workflow execution frames + metadata

# =========================
# CONFIG (edit these 5 lines)
# =========================
$ClientId     = 'PUT_YOUR_CLIENT_ID_HERE'
$ClientSecret = 'PUT_YOUR_CLIENT_SECRET_HERE'
$Environment  = 'mypurecloud.com.au'      # AU: mypurecloud.com.au, US-East: mypurecloud.com, etc.
$WorkflowName = ''                        # Optional. Exact (or partial) match. Leave blank for ALL workflows.
$DaysBack     = 0                         # 0 = today only; 1 = yesterday; etc.

# =========================
# ADVANCED (usually leave as-is)
# =========================
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
$BaseApi = "https://api.$Environment"
$Login   = "https://login.$Environment"

# Compute interval in UTC: start of (today - DaysBack) to end of that day
$localStart = (Get-Date).Date.AddDays(-1 * [int]$DaysBack)
$localEnd   = $localStart.AddDays(1).AddSeconds(-1)
$startUtc   = $localStart.ToUniversalTime()
$endUtc     = $localEnd.ToUniversalTime()
$Interval   = "{0:o}/{1:o}" -f $startUtc, $endUtc

$OutCsv     = Join-Path (Get-Location) ("WorkflowExecutionFrames_{0:yyyyMMdd_HHmmss}.csv" -f (Get-Date))

function Get-AccessToken {
    param(
        [string]$ClientId, [string]$ClientSecret, [string]$Login
    )
    $b64 = [Convert]::ToBase64String([Text.Encoding]::ASCII.GetBytes("$ClientId:$ClientSecret"))
    $headers = @{ Authorization = "Basic $b64" }
    $body    = "grant_type=client_credentials"
    try {
        $resp = Invoke-RestMethod -Method POST -Uri "$Login/oauth/token" -Headers $headers -ContentType "application/x-www-form-urlencoded" -Body $body
        return $resp.access_token
    } catch {
        throw "Auth failed: $($_.Exception.Message)"
    }
}

function Invoke-GC {
    param(
        [Parameter(Mandatory)] [string]$Method,
        [Parameter(Mandatory)] [string]$Path,
        [string]$Token,
        [object]$Body = $null,
        [hashtable]$ExtraHeaders = $null
    )
    $headers = @{ Authorization = "Bearer $Token" }
    if ($ExtraHeaders) { $ExtraHeaders.GetEnumerator() | ForEach-Object { $headers[$_.Key] = $_.Value } }
    $uri = if ($Path -like 'http*') { $Path } else { "$BaseApi$Path" }
    if ($Body -ne $null -and -not ($Body -is [string])) { $Body = ($Body | ConvertTo-Json -Depth 10) }
    return Invoke-RestMethod -Method $Method -Uri $uri -Headers $headers -ContentType "application/json" -Body $Body
}

function Get-AllWorkflows {
    param([string]$Token)
    $all = @()
    $page = 1
    do {
        $resp = Invoke-GC -Method GET -Path "/api/v2/flows?pageSize=200&pageNumber=$page" -Token $Token
        $entities = @()
        if ($resp.entities) { $entities = $resp.entities }
        elseif ($resp.items) { $entities = $resp.items }
        else { $entities = @() }
        $workflows = $entities | Where-Object { $_.type -eq 'WORKFLOW' }
        $all += $workflows
        $page += 1
        $more = ($entities.Count -gt 0 -and ($resp.nextUri -or ($resp.pageCount -as [int]) -ge ($page)))
    } while ($more)
    return $all
}

function Find-WorkflowIds {
    param([string]$Token, [string]$Name)
    $flows = Get-AllWorkflows -Token $Token
    if ([string]::IsNullOrWhiteSpace($Name)) {
        return $flows.id
    } else {
        # exact or partial (case-insensitive)
        $matched = $flows | Where-Object { $_.name -like "*$Name*" }
        if (-not $matched) { throw "No workflows matched name '$Name'." }
        return $matched.id
    }
}

function Query-FlowInstances {
    param([string]$Token, [string[]]$FlowIds, [string]$Interval)
    # Get all flowInstanceIds for the interval (groupBy flowInstanceId)
    $preds = @(@{ type='dimension'; dimension='flowType'; value='workflow' })
    if ($FlowIds -and $FlowIds.Count -gt 0) {
        # We'll OR the flowIds inside a clause to avoid massive result sets
        $flowIdPreds = $FlowIds | ForEach-Object { @{ type='dimension'; dimension='flowId'; value=$_ } }
        $filter = @{
            type    = 'and'
            clauses = @(@{ type='or'; predicates = $flowIdPreds })
            predicates = $preds
        }
    } else {
        $filter = @{ type='and'; predicates = $preds }
    }

    $body = @{
        interval = $Interval
        filter   = $filter
        groupBy  = @('flowInstanceId','flowId','flowName','flowVersion')
        metrics  = @()  # not required
    }

    $resp = Invoke-GC -Method POST -Path "/api/v2/analytics/flows/aggregates/query" -Token $Token -Body $body
    $ids = @()
    foreach ($r in $resp.results) {
        if ($r.group.flowInstanceId) { $ids += $r.group.flowInstanceId }
    }
    $ids = $ids | Select-Object -Unique
    return $ids
}

function Start-ExecutionExportJob {
    param(
        [string]$Token,
        [string]$Interval,
        [string[]]$FlowInstanceIds = $null,
        [string[]]$FlowIds = $null
    )
    # Build filter: flowType=workflow AND (OR flowInstanceIds | OR flowIds) within interval
    $predBase = @(@{ type='dimension'; dimension='flowType'; value='workflow' })
    $clauses = @()

    if ($FlowInstanceIds -and $FlowInstanceIds.Count -gt 0) {
        $clauses += @{
            type='or'
            predicates= ($FlowInstanceIds | ForEach-Object { @{ type='dimension'; dimension='flowInstanceId'; value=$_ } })
        }
    }
    elseif ($FlowIds -and $FlowIds.Count -gt 0) {
        $clauses += @{
            type='or'
            predicates= ($FlowIds | ForEach-Object { @{ type='dimension'; dimension='flowId'; value=$_ } })
        }
    }

    $jobBody = @{
        interval = $Interval
        filter   = @{
            type      = 'and'
            predicates= $predBase
            clauses   = $clauses
        }
    }
    $job = Invoke-GC -Method POST -Path "/api/v2/analytics/flows/executions/jobs" -Token $Token -Body $jobBody
    return $job.id
}

function Wait-Job {
    param([string]$Token, [string]$JobId, [int]$TimeoutSec = 180)
    $expiry = (Get-Date).AddSeconds($TimeoutSec)
    do {
        $s = Invoke-GC -Method GET -Path "/api/v2/analytics/flows/executions/jobs/$JobId" -Token $Token
        if ($s.state -eq 'FULFILLED') { return $s.resultsUrl }
        if ($s.state -eq 'FAILED') { throw "Export job failed: $($s | ConvertTo-Json -Depth 6)" }
        Start-Sleep -Seconds 3
    } while ((Get-Date) -lt $expiry)
    throw "Export job timed out after $TimeoutSec seconds."
}

function Get-JsonFromGzipUrl {
    param([string]$Url)
    $tmpGz = [System.IO.Path]::GetTempFileName()
    try {
        Invoke-WebRequest -Uri $Url -OutFile $tmpGz -Headers @{ "Accept-Encoding"="identity" } | Out-Null
        $fs   = [System.IO.File]::OpenRead($tmpGz)
        $gs   = New-Object System.IO.Compression.GzipStream($fs, [System.IO.Compression.CompressionMode]::Decompress)
        $sr   = New-Object System.IO.StreamReader($gs, [Text.Encoding]::UTF8)
        $json = $sr.ReadToEnd()
        $sr.Close(); $gs.Close(); $fs.Close()
        return $json
    } finally {
        if (Test-Path $tmpGz) { Remove-Item $tmpGz -Force -ErrorAction SilentlyContinue }
    }
}

function Coalesce {
    param([Parameter(ValueFromRemainingArguments=$true)] $values)
    foreach ($v in $values) {
        if ($null -ne $v -and -not ([string]::IsNullOrWhiteSpace([string]$v))) { return $v }
    }
    return $null
}

# -------------- MAIN --------------

Write-Host "Authenticating to Genesys Cloud ($Environment)..." -ForegroundColor Cyan
$Token = Get-AccessToken -ClientId $ClientId -ClientSecret $ClientSecret -Login $Login
Write-Host "OK.`nInterval: $Interval" -ForegroundColor Green

# Resolve workflow IDs (optional filter)
$FlowIds = @()
if (-not [string]::IsNullOrWhiteSpace($WorkflowName)) {
    Write-Host "Finding workflow(s) matching: $WorkflowName" -ForegroundColor Cyan
    $FlowIds = Find-WorkflowIds -Token $Token -Name $WorkflowName
    Write-Host ("Matched {0} workflow id(s)." -f $FlowIds.Count) -ForegroundColor Green
}

# Get all flow instance IDs for the interval (so we know data volume)
Write-Host "Querying flow instances for interval..." -ForegroundColor Cyan
$InstanceIds = Query-FlowInstances -Token $Token -FlowIds $FlowIds -Interval $Interval
if (-not $InstanceIds -or $InstanceIds.Count -eq 0) {
    Write-Host "No workflow executions found in interval." -ForegroundColor Yellow
    return
}
Write-Host ("Found {0} flow instance(s)." -f $InstanceIds.Count) -ForegroundColor Green

# Create export job(s) in manageable chunks (IDs OR interval only)
# Job endpoint can return ALL matching executions in one file.
# For very large sets we chunk by 200 instanceIds per job to keep request bodies reasonable.
$AllEvents = New-Object System.Collections.Generic.List[object]
$chunks = if ($InstanceIds.Count -gt 0) { [System.Linq.Enumerable]::ToList($InstanceIds).ToArray() } else { @() }
if ($chunks.Count -gt 0) {
    # Split into chunks of 200 IDs
    $chunkSize = 200
    for ($i=0; $i -lt $InstanceIds.Count; $i += $chunkSize) {
        $slice = $InstanceIds[$i..([Math]::Min($i+$chunkSize-1,$InstanceIds.Count-1))]
        Write-Host ("Starting export job for {0} instanceIds ({1}-{2})..." -f $slice.Count, $i+1, $i+$slice.Count) -ForegroundColor Cyan
        $jobId = Start-ExecutionExportJob -Token $Token -Interval $Interval -FlowInstanceIds $slice
        $url   = Wait-Job -Token $Token -JobId $jobId -TimeoutSec 240
        $json  = Get-JsonFromGzipUrl -Url $url
        $payload = $json | ConvertFrom-Json
        # payload may be { flowExecutionEvents=[...] } or an array. Handle both.
        $events = if ($payload.flowExecutionEvents) { $payload.flowExecutionEvents } else { $payload }
        foreach ($e in $events) { [void]$AllEvents.Add($e) }
    }
} else {
    # Fallback: interval + (optional) FlowIds filter
    Write-Host "Starting export job for entire interval (no explicit instance list)..." -ForegroundColor Cyan
    $jobId = Start-ExecutionExportJob -Token $Token -Interval $Interval -FlowIds $FlowIds
    $url   = Wait-Job -Token $Token -JobId $jobId -TimeoutSec 240
    $json  = Get-JsonFromGzipUrl -Url $url
    $payload = $json | ConvertFrom-Json
    $events = if ($payload.flowExecutionEvents) { $payload.flowExecutionEvents } else { $payload }
    foreach ($e in $events) { [void]$AllEvents.Add($e) }
}

if ($AllEvents.Count -eq 0) {
    Write-Host "Export completed, but no events returned (check execution data settings / interval)." -ForegroundColor Yellow
    return
}

Write-Host ("Flattening {0} execution event(s)..." -f $AllEvents.Count) -ForegroundColor Cyan

$rows = foreach ($e in $AllEvents) {
    # Coalesce common fields defensively (structure can vary)
    $flowId         = Coalesce $e.flowId $e.flow?.id
    $flowName       = Coalesce $e.flowName $e.flow?.name
    $flowVersion    = Coalesce $e.flowVersion $e.flow?.version
    $flowInstanceId = Coalesce $e.flowInstanceId $e.flow?.flowInstanceId $e.instanceId
    $executionId    = Coalesce $e.executionId $e.execution?.id
    $timestamp      = Coalesce $e.eventDateTime $e.timestamp
    $objectType     = Coalesce $e.objectType $e.actionType
    $objectName     = Coalesce $e.objectName $e.actionName
    $eventName      = Coalesce $e.eventName $e.event

    # Try to infer the branch/path taken (varies by block type)
    $pathHint = Coalesce `
        $e.outputData?.path `
        $e.outputData?.caseLabel `
        $e.outputData?.choice `
        $e.outputData?.selectedMenuChoice `
        $e.outputData?.selectedValue `
        $e.inputData?.path `
        $e.inputData?.choice `
        $e.framePath `
        $e.branch

    $err = $null
    if ($e.errorInfo) {
        $err = ($e.errorInfo | ConvertTo-Json -Compress -Depth 6)
    }

    [PSCustomObject]@{
        FlowName        = $flowName
        FlowId          = $flowId
        FlowVersion     = $flowVersion
        FlowInstanceId  = $flowInstanceId
        ExecutionId     = $executionId
        EventTimeUtc    = $timestamp
        ObjectType      = $objectType
        ObjectName      = $objectName
        EventName       = $eventName
        PathTaken       = $pathHint
        # Keep raw I/O compact for later drills
        InputJson       = if ($e.inputData)  { $e.inputData  | ConvertTo-Json -Compress -Depth 6 } else { $null }
        OutputJson      = if ($e.outputData) { $e.outputData | ConvertTo-Json -Compress -Depth 6 } else { $null }
        ErrorJson       = $err
    }
}

$rows | Export-Csv -NoTypeInformation -Encoding UTF8 -Path $OutCsv
Write-Host "`nDONE. CSV saved to:`n$OutCsv" -ForegroundColor Green
