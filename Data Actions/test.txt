<# 
Start-GenesysHistoricalAdherenceBulk.ps1
- All values hard-coded in CONFIG
- Starts WFM Historical Adherence (bulk), polls to completion,
  downloads results, and writes a flattened CSV.
- Extra debug prints to diagnose "no jobId in response".
#>

# =======================
# ======= CONFIG ========
# =======================
$AccessToken       = 'PASTE_YOUR_ACCESS_TOKEN_HERE'   # Bearer token (valid)
$RegionBase        = 'https://api.mypurecloud.com.au' # AU region
$ManagementUnitId  = 'YOUR_MU_ID'                     # e.g. '16083220-1ec5-4868-863c-d78af2a65287'
$StartDate         = '2025-08-18'                     # YYYY-MM-DD (Sydney calendar)
$EndDate           = '2025-08-18'                     # YYYY-MM-DD
$TimeZone          = 'Australia/Sydney'               # IANA timezone

# Output
$OutFolder           = "$PWD\Adherence_Output"
$PollIntervalSeconds = 15
$PollTimeoutMinutes  = 15

# =======================
# ====== SCRIPT =========
# =======================
$ErrorActionPreference = 'Stop'
if (-not (Test-Path $OutFolder)) { New-Item -ItemType Directory -Path $OutFolder | Out-Null }
$stamp        = Get-Date -Format 'yyyyMMdd_HHmmss'
$RunPrefix    = "adh_$($StartDate)_$($EndDate)_$stamp"
$LogFile      = Join-Path $OutFolder "$RunPrefix.log"
$FlatCsvFile  = Join-Path $OutFolder "$RunPrefix.flat.csv"

function Write-Log($msg, [ConsoleColor]$color = [ConsoleColor]::Gray) {
  $ts = (Get-Date).ToString('yyyy-MM-dd HH:mm:ss')
  $line = "[$ts] $msg"
  Write-Host $line -ForegroundColor $color
  Add-Content -Path $LogFile -Value $line
}

function Invoke-Genesys {
  param(
    [ValidateSet('GET','POST')] [string]$Method,
    [Parameter(Mandatory)] [string]$Uri,
    [string]$RawJsonBody = $null
  )
  $headers = @{ "Authorization" = "Bearer $AccessToken" }
  if ($Method -eq 'POST') {
    $headers['Content-Type'] = 'application/json'
    return Invoke-RestMethod -Method POST -Uri $Uri -Headers $headers -Body $RawJsonBody
  } else {
    return Invoke-RestMethod -Method GET -Uri $Uri -Headers $headers
  }
}

# ---- Debug: who am I & MU visibility ----
try {
  Write-Log "DEBUG: GET /api/v2/tokens/me" ([ConsoleColor]::DarkCyan)
  $who = Invoke-Genesys -Method GET -Uri "$RegionBase/api/v2/tokens/me"
  $orgName = $who.organization.name
  $homeRegion = $who.homeRegion
  Write-Log "Identity: oauth-client in org '$orgName', homeRegion '$homeRegion'"
} catch { Write-Log "DEBUG tokens/me failed: $($_.Exception.Message)" ([ConsoleColor]::DarkYellow) }

try {
  Write-Log "DEBUG: GET MU $ManagementUnitId" ([ConsoleColor]::DarkCyan)
  $muChk = Invoke-Genesys -Method GET -Uri "$RegionBase/api/v2/workforcemanagement/managementunits/$ManagementUnitId"
  if ($muChk.id) { Write-Log "MU visible: $($muChk.name) ($($muChk.id))" } else { Write-Log "MU visible but no name/id? Check response." }
} catch { Write-Log "DEBUG MU visibility failed: $($_.Exception.Message)" ([ConsoleColor]::DarkYellow) }

# ---- 1) POST bulk job (use literal JSON) ----
Write-Log "Starting Historical Adherence bulk job..." ([ConsoleColor]::Cyan)
$startUri = "$RegionBase/api/v2/workforcemanagement/adherence/historical/bulk"

# Build JSON as a literal string to avoid escaping/formatting issues
$PostBody = @"
{
  "items": [
    {
      "managementUnitId": "$ManagementUnitId",
      "startDate": "$StartDate",
      "endDate": "$EndDate"
    }
  ],
  "timeZone": "$TimeZone"
}
"@

try {
  $startResp = Invoke-Genesys -Method POST -Uri $startUri -RawJsonBody $PostBody
} catch {
  Write-Log "POST failed: $($_.Exception.Message)" ([ConsoleColor]::Red)
  Write-Log "POST body sent: $PostBody" ([ConsoleColor]::Yellow)
  throw
}

Write-Log "Raw POST response:" ([ConsoleColor]::Yellow)
try { $startResp | ConvertTo-Json -Depth 20 | Write-Host } catch { Write-Host ($startResp | Out-String) }

# Check for jobId / selfUri
if (-not $startResp.jobId -or -not $startResp.selfUri) {
  Write-Log "ERROR: Start response missing jobId or selfUri. Above is the raw response." ([ConsoleColor]::Red)
  Write-Log "POST body sent again for reference:" ([ConsoleColor]::Yellow)
  Write-Host $PostBody
  throw "Start response did not include jobId/selfUri. See logs above."
}

$jobId   = $startResp.jobId
$selfUri = $startResp.selfUri
$statusUrl = if ($selfUri -match '^https?://') { $selfUri } else { "$RegionBase$selfUri" }

Write-Log "Job started. jobId=$jobId"
Write-Log "Status URL: $statusUrl"
if ($startResp.state) { Write-Log "Initial state: $($startResp.state)" }

# ---- 2) Poll until Complete (follow selfUri) ----
Write-Log "Polling every $PollIntervalSeconds seconds (timeout $PollTimeoutMinutes min)..." ([ConsoleColor]::Cyan)
Start-Sleep -Seconds 2  # tiny grace period

$deadline  = (Get-Date).AddMinutes($PollTimeoutMinutes)
$state     = $null
$lastState = $null
$status    = $null

while ($true) {
  try {
    $status = Invoke-Genesys -Method GET -Uri $statusUrl
  } catch {
    Write-Log "Transient polling error: $($_.Exception.Message)" ([ConsoleColor]::DarkYellow)
    if ((Get-Date) -gt $deadline) { throw "Timeout (and transient errors) waiting for job." }
    Start-Sleep -Seconds $PollIntervalSeconds
    continue
  }

  $state = $status.state
  if ($state -ne $lastState) {
    Write-Log "state = $state"
    $lastState = $state
  }

  if ($state -eq 'Failed') {
    $msg = if ($status.errorMessage) { $status.errorMessage } else { 'Historical adherence job failed.' }
    Write-Log "Job failed: $msg" ([ConsoleColor]::Red)
    Write-Log "Full status body:" ([ConsoleColor]::Yellow)
    try { $status | ConvertTo-Json -Depth 20 | Write-Host } catch { Write-Host ($status | Out-String) }
    throw "Job failed: $msg"
  }

  if ($state -eq 'Complete') { break }
  if ((Get-Date) -gt $deadline) { throw "Timeout waiting for job to Complete." }

  Start-Sleep -Seconds $PollIntervalSeconds
}

# ---- 3) Download all result files ----
$urls = @()
if ($status.downloadUrls) { $urls = @($status.downloadUrls) }
if ($urls.Count -eq 0) {
  Write-Log "Complete, but no downloadUrls (no data for given range/users?)" ([ConsoleColor]::Yellow)
} else {
  Write-Log "Downloading $($urls.Count) result file(s)..." ([ConsoleColor]::Cyan)
}

$resultFiles = @()
$idx = 0
foreach ($u in $urls) {
  $idx++
  $file = Join-Path $OutFolder "$RunPrefix.part$($idx).json"
  try {
    Invoke-WebRequest -Method GET -Uri $u -OutFile $file | Out-Null
    Write-Log "Downloaded: $file" ([ConsoleColor]::Green)
    $resultFiles += $file
  } catch {
    Write-Log "Failed to download $u : $($_.Exception.Message)" ([ConsoleColor]::Red)
    throw
  }
}

# ---- 4) Flatten to CSV (user × dayMetrics) ----
function Flatten-Adherence {
  param([string[]]$Files, [string]$CsvOut)

  $rows = New-Object System.Collections.Generic.List[object]

  foreach ($f in $Files) {
    if (-not (Test-Path $f)) { continue }
    $arr = Get-Content $f -Raw | ConvertFrom-Json
    if ($arr -eq $null) { continue }
    foreach ($item in $arr) {
      $user = $item.user
      $muid = $user.managementUnitId
      $uid  = $user.id
      $uname= $user.name
      $team = if ($user.PSObject.Properties.Name -contains 'team') { $user.team } else { $null }

      foreach ($dm in ($item.dayMetrics)) {
        $rows.Add([PSCustomObject]@{
          userId                         = $uid
          userName                       = $uname
          teamName                       = $(if ($team) { $team } else { '—' })
          muId                           = $muid
          date                           = $dm.date
          adherencePercent               = $dm.adherencePercent
          conformancePercent             = $dm.conformancePercent
          exceptionDurationMinutes       = $dm.exceptionDurationMinutes
          outOfAdherenceDurationMinutes  = $dm.outOfAdherenceDurationMinutes
        }) | Out-Null
      }
    }
  }

  if ($rows.Count -gt 0) {
    $rows | Export-Csv -Path $CsvOut -NoTypeInformation -Encoding UTF8
    Write-Log "Flattened CSV written: $CsvOut" ([ConsoleColor]::Green)
  } else {
    Write-Log "No rows produced (empty metrics in downloaded files)." ([ConsoleColor]::Yellow)
  }
}

if ($resultFiles.Count -gt 0) {
  Write-Log "Flattening to CSV..." ([ConsoleColor]::Cyan)
  Flatten-Adherence -Files $resultFiles -CsvOut $FlatCsvFile
}

Write-Log "Done." ([ConsoleColor]::Green)
Write-Host ""
Write-Host "Outputs:"
Write-Host "  Log : $LogFile"
if ($resultFiles.Count -gt 0) {
  $resultFiles | ForEach-Object { Write-Host "  JSON: $_" }
}
if (Test-Path $FlatCsvFile) { Write-Host "  CSV : $FlatCsvFile" }
