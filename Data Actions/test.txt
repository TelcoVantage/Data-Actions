<# 
    Genesys Cloud â€“ Pull audits for a single user (last 12 days)
    - Queries both:
        A) events performed by the user (actor)
        B) events targeting that user as the entity
    - Asynchronous Audits API flow:
        POST  /api/v2/audits/query     -> 202 + transactionId
        GET   /api/v2/audits/query/{transactionId}
        GET   /api/v2/audits/query/{transactionId}/results (with nextUri paging)
    - Outputs: audits_{USERID}_YYYYMMDD_HHmm.csv and .json
#>

# ------------------- CONFIG: FILL THESE -------------------
$CLIENT_ID      = "<PUT_YOUR_CLIENT_ID_HERE>"
$CLIENT_SECRET  = "<PUT_YOUR_CLIENT_SECRET_HERE>"
$ORG_REGION     = "mypurecloud.com.au"   # e.g., mypurecloud.com, mypurecloud.ie, etc.
$TARGET_USER_ID = "<PUT_TARGET_USER_GUID_HERE>"
$DAYS_BACK      = 12
# ------------------- END CONFIG ---------------------------

# ---------- Time interval (UTC) ----------
$nowUtc   = (Get-Date).ToUniversalTime()
$startUtc = $nowUtc.AddDays(-$DAYS_BACK)
# Using the "o" round-trip format specifier is the most robust way to create ISO-8601 timestamps
$interval = "{0}/{1}" -f ($startUtc.ToString("o")), ($nowUtc.ToString("o"))

# ---------- OAuth: Client Credentials ----------
$tokenUrl = "https://login.$ORG_REGION/oauth/token"
$pair     = "{0}:{1}" -f $CLIENT_ID, $CLIENT_SECRET
$basic    = [Convert]::ToBase64String([System.Text.Encoding]::ASCII.GetBytes($pair))
$headers  = @{ "Authorization" = "Basic $basic" }

try {
    $tokenResp = Invoke-RestMethod -Method Post -Uri $tokenUrl -Headers $headers `
        -ContentType "application/x-www-form-urlencoded" -Body "grant_type=client_credentials"
} catch {
    Write-Error "Failed to obtain token. Check client ID/secret/region and client roles. $($_.Exception.Message)"
    exit 1
}

$accessToken = $tokenResp.access_token
if (-not $accessToken) { Write-Error "No access_token in token response."; exit 1 }

# ---------- Common API setup ----------
$apiBase = "https://api.$ORG_REGION"
$authz   = @{ "Authorization" = "Bearer $accessToken"; "Content-Type" = "application/json" }

function Start-AuditQuery {
    param([Parameter(Mandatory)] [hashtable] $Body)
    $url = "$apiBase/api/v2/audits/query"
    $json = ($Body | ConvertTo-Json -Depth 10)
    try {
        # Using Invoke-WebRequest to handle the expected 202 status code correctly
        $resp = Invoke-WebRequest -Method Post -Uri $url -Headers $authz -Body $json
        if ($resp.StatusCode -ne 202) { throw "Unexpected status code: $($resp.StatusCode) body: $($resp.Content)" }
        ($resp.Content | ConvertFrom-Json).id
    } catch { throw "Audit query create failed: $($_.Exception.Message)" }
}

function Wait-AuditQueryReady {
    param(
        [Parameter(Mandatory)] [string] $TransactionId,
        [int] $TimeoutSec = 120,
        [int] $PollMs = 1200
    )
    $statusUrl = "$apiBase/api/v2/audits/query/$TransactionId"
    $sw = [System.Diagnostics.Stopwatch]::StartNew()
    while ($sw.Elapsed.TotalSeconds -lt $TimeoutSec) {
        try {
            $s = Invoke-RestMethod -Method Get -Uri $statusUrl -Headers $authz
            # FIX: Using the exact state values from the API documentation for precision.
            if ($s.state -eq "SUCCEEDED") { return $true }
            if ($s.state -in @("FAILED", "CANCELLED")) { throw "Query state: $($s.state). Message: $($s.errorMessage)" }
        } catch { throw "Status check failed: $($_.Exception.Message)" }
        Start-Sleep -Milliseconds $PollMs
    }
    throw "Timed out waiting for audit query to complete."
}

function Get-AuditResultsAllPages {
    param([Parameter(Mandatory)] [string] $TransactionId)
    $results = @()
    $url = "$apiBase/api/v2/audits/query/$TransactionId/results"
    while ($true) {
        $resp = Invoke-RestMethod -Method Get -Uri $url -Headers $authz
        if ($resp.entities) { $results += $resp.entities }
        # The 'nextUri' is a relative path, so it must be combined with the apiBase
        if ($resp.nextUri) { $url = "$apiBase$($resp.nextUri)" } else { break }
    }
    $results
}

# ---------- Build two queries ----------
Write-Host "Building audit queries for user $TARGET_USER_ID..."
Write-Host "Interval: $interval"

# Actor = events performed BY the user
# FIX: The query for actor events was using an incorrect body structure.
# The API requires a 'filters' array to specify the acting user via the 'UserId' property.
$bodyActor = @{
    interval = $interval
    filters  = @(
        @{ property = "UserId"; values = @($TARGET_USER_ID) }
    )
    pageSize = 100
}

# Entity = events targeting that user (their record changed)
$bodyEntity = @{
    interval = $interval
    filters  = @(
        @{ property = "EntityType"; values = @("User") },
        @{ property = "EntityId";   values = @($TARGET_USER_ID) }
    )
    pageSize = 100
}

Write-Host "`nSubmitting audit queries..."

try {
    $txActor  = Start-AuditQuery -Body $bodyActor
    $txEntity = Start-AuditQuery -Body $bodyEntity

    Write-Host "Actor transactionId : $txActor"
    Write-Host "Entity transactionId: $txEntity"

    Write-Host "Waiting for queries to complete..."
    [void](Wait-AuditQueryReady -TransactionId $txActor)
    [void](Wait-AuditQueryReady -TransactionId $txEntity)
    
    Write-Host "Fetching results..."
    $actorEvents  = Get-AuditResultsAllPages -TransactionId $txActor
    $entityEvents = Get-AuditResultsAllPages -TransactionId $txEntity
} catch { Write-Error $_; exit 1 }

# ---------- Merge, de-dup (by id), sort ----------
$all = @($actorEvents + $entityEvents) | Group-Object id | ForEach-Object { $_.Group[0] } |
       Sort-Object -Property timestamp -Descending

if (-not $all -or $all.Count -eq 0) {
    Write-Host "`nNo audit events found for user $TARGET_USER_ID in the last $DAYS_BACK days."
    return
}

# ---------- Outputs ----------
$stamp   = (Get-Date).ToString("yyyyMMdd_HHmm")
$baseOut = "audits_$($TARGET_USER_ID)_$stamp"

$all | ConvertTo-Json -Depth 20 | Out-File -Encoding UTF8 -FilePath "$baseOut.json"

$flat = $all | ForEach-Object {
    $pc = $_.propertyChanges
    $changes = $null
    if ($pc) {
        $changes = ($pc | ForEach-Object {
            $n = $_.property
            $o = if ($_.oldValues) { ($_.oldValues -join "|") } else { "" }
            $v = if ($_.newValues) { ($_.newValues -join "|") } else { "" }
            # Use a format string to prevent errors if values contain special characters
            "{0}: '{1}' -> '{2}'" -f $n, $o, $v
        }) -join "; "
    }
    [pscustomobject]@{
        Timestamp     = $_.timestamp
        ServiceName   = $_.serviceName
        Action        = $_.action
        EntityType    = $_.entityType
        EntityName    = $_.entityName
        EntityId      = $_.entityId
        UserName      = $_.userName # Actor Name
        UserId        = $_.userId   # Actor ID
        CorrelationId = $_.correlationId
        IPAddress     = $_.ipAddress
        Application   = $_.application
        Changes       = $changes
    }
}

$flat | Export-Csv -NoTypeInformation -Encoding UTF8 -Path "$baseOut.csv"

Write-Host "`nDone. Found $($all.Count) events."
Write-Host "JSON: $baseOut.json"
Write-Host "CSV : $baseOut.csv"
